# PRD — Sidecar для локального поиска по Telegram (Saved Messages + свои чаты/каналы)

## 1. Коротко о продукте
Локальное приложение (один бинарник), которое подключается к аккаунту Telegram как пользователь, индексирует **только Saved Messages и выбранные “свои” чаты/каналы**, и предоставляет:

- минимальный UI: выбор чатов/каналов + “гуглоподобная” строка поиска;
- поиск по тексту (FTS) и опционально гибридный (FTS + семантика через embeddings API);
- открытие найденных результатов в официальном клиенте Telegram через deep link’и;
- MCP-сервер, чтобы внешние LLM/агенты могли использовать поиск как tool.

> Важно: в условиях Telegram есть ограничения на “scraping/indexing/aggregation” данных платформы для AI/ML. Нужно иметь режим **FTS-only** по умолчанию и явное включение семантики с предупреждением и подтверждением пользователя.  
> Источники:  
> - Telegram Content Licensing Terms: https://telegram.org/tos/content-licensing  
> - Telegram API Terms (ссылка на ограничения AI scraping): https://core.telegram.org/api/terms

---

## 2. Цели и KPI

### Цели
1) Быстро находить сообщения “по смыслу” и “по словам”.  
2) Полностью локальное хранение и индекс: без внешних сервисов/демонов (кроме embeddings API).  
3) Управляемая индексация: per-chat политики “лениво/полно”, отдельно для URL и вложений.  
4) Интеграция через MCP.

### Наблюдаемые показатели (ориентиры)
- Время ответа поиска UI: p95 < 300 мс на типичных объёмах (десятки тыс. сообщений/чанков).
- Инкрементальная индексация: новые сообщения попадают в индекс “почти сразу” (секунды–десятки секунд).
- Стабильность: перезапуск не требует переиндексации, продолжает работу с последней позиции.

---

## 3. Пользователи и сценарии

### Пользователь
Один владелец приложения (локальная установка).

### Ключевые сценарии
1) **Поиск по словам**: “где я писал про X?” → FTS.  
2) **Поиск по смыслу**: “помню идею, не помню формулировку” → Hybrid.  
3) **Per-chat политика**: “этот канал индексировать полностью, этот — лениво; URL в одном — да, в другом — нет”.  
4) **Открыть в Telegram**: клик по результату → открыть в официальном клиенте Telegram.  
5) **Интеграция**: LLM вызывает MCP tool `search_messages` → получает ссылки и контекст.

---

## 4. Область охвата (Scope)

### Входит (MVP)
- Подключение к Telegram как пользователь.
- Выбор чатов/каналов для индексации + Saved Messages.
- Инкрементальная синхронизация новых/отредактированных/удалённых сообщений.
- Локальная база (SQLite) + FTS5 индекс.
- Минимальный UI (localhost web).
- Открытие найденного сообщения в Telegram (best-effort).
- MCP: `search_messages`, `get_message`, `list_chats`, `index_status`.

### Входит (после MVP / Beta)
- Семантика через embeddings API (OpenAI compatible), модель `text-embedding-3-large`.
- Локальный HNSW индекс внутри приложения (один бинарник).
- URL-fetch + извлечение текста (HTML → “основной текст”) по политикам.
- Индексация вложений (только “текстовые документы”) по политикам.

### Не входит
- OCR изображений, STT аудио/видео.
- Индексация чужих чатов/каналов или массовая индексация публичных каналов.
- Отправка/модерация сообщений, реакции и т.п. (только чтение).

---

## 5. Функциональные требования

### 5.1. Управление источниками (чаты/каналы)
Для каждого чата/канала:
- `enabled`: индексировать или нет.
- `history_mode`: `lazy | full`
  - `full`: подтянуть историю (бэкфилл).
  - `lazy`: не тащить историю, индексировать только “хвост” (новые сообщения).
- `attachments_mode`: `off | lazy | full`
- `urls_mode`: `off | lazy | full`

### 5.2. Индексация сообщений
- Индексировать текст сообщения и подпись к вложениям.
- Учитывать edits и deletes:
  - edit → обновить текст/чанки/вектора (если включено).
  - delete → пометить как удалённое, убрать из индекса.

### 5.3. Индексация вложений (по политикам)
- Поддерживаемые типы (минимальный набор): `text/plain`, `text/markdown`, `text/html`, `application/json`, `application/pdf`, `application/vnd.openxmlformats-officedocument.wordprocessingml.document` (DOCX).
- `lazy`: не скачивать/не извлекать до явного действия (кнопка “проиндексировать вложения” или фоновая джоба по расписанию).
- `full`: при бэкфилле и при новых сообщениях извлекать сразу.

### 5.4. URL: fetch + извлечение текста (по политикам)
- Из текста сообщения извлекать URL.
- `lazy`: сохранять URL как “pending”, fetch делать по запросу/кнопке/планировщику.
- `full`: fetch делать сразу.
- Извлечение контента:
  - HTML → “основной текст” (readability-подобное).
  - Сохранять title, final URL, timestamp, хэш контента.

### 5.5. Поиск
Единое поле поиска с фильтрами:
- чат/канал (мультивыбор)
- диапазон дат
- has_url / has_attachment
- режим: `FTS | Hybrid` (если Hybrid включён)

#### Ранжирование
- FTS: `bm25()` (меньше = лучше).
- Hybrid: объединение (например RRF):
  - кандидаты из FTS + кандидаты из HNSW
  - итоговый topK + сниппеты.

Источник по FTS5: https://www.sqlite.org/fts5.html

### 5.6. Открытие результата в Telegram
- Для публичных/приватных постов использовать “message links / deep links” (best-effort).
- Если прямой линк недоступен (часто для Saved Messages):
  - открыть чат,
  - показать “перейти по времени/скопировать фрагмент” (fallback).

Источник: https://core.telegram.org/api/links

### 5.7. MCP
- Запуск встроенного MCP-сервера в том же процессе.
- Минимальные tools:
  - `search_messages(query, filters, top_k, mode=fts|hybrid)`
  - `get_message(chat_id, message_id)`
  - `list_chats()`
  - `set_chat_policy(chat_id, ...)`
  - `index_status()`

Источник: https://github.com/modelcontextprotocol/go-sdk

---

## 6. Нефункциональные требования (NFR)

### 6.1. Один бинарник
- Без отдельных сервисов (Qdrant/Redis и т.п.).
- Локальные файлы: база SQLite + файлы индекса HNSW + кеш вложений/URL (по настройкам).

### 6.2. Надёжность
- Идемпотентность задач индексации.
- Продолжение после перезапуска: чекпойнты (последний обработанный offset/время/ID).

### 6.3. Производительность и квоты
- Параллелизм ограничиваем: N воркеров для fetch/embeddings.
- Rate limiting для Telegram и для embeddings API.
- Встроенный backoff на FLOOD_WAIT и сетевые ошибки.

### 6.4. Безопасность URL-fetch
- Лимиты:
  - max_size (например 5MB)
  - timeout (например 10s)
  - max_redirects
  - max_urls_per_message
- SSRF-гигиена:
  - запрещать private IP ranges, localhost, link-local, *.local
  - DNS re-resolve перед запросом и проверка IP
- Опционально: allowlist доменов.

### 6.5. Приватность
- По умолчанию всё локально.
- “Embeddings mode” — явное включение и предупреждение, что текст уходит во внешний API.
- Кнопка “Purge”: удалить индекс, вектора, кеш и историю задач.

---

## 7. Релизный план

### MVP (FTS-only)
- Telegram sync (Saved Messages + выбранные чаты/каналы).
- SQLite + FTS5.
- UI: выбор чатов, поиск, выдача, статус.
- MCP: базовые tools.

### Beta (Hybrid + HNSW)
- embeddings API client (OpenAI-compatible).
- HNSW индекс в приложении.
- Fusion ранжирования.

### v1 (URL + вложения)
- URL-fetch pipeline (lazy/full).
- Индексация вложений (lazy/full).
- Расширенные лимиты и наблюдаемость (метрики/лог).

---

## 8. Риски и смягчение
- Правила Telegram по AI scraping/indexing → FTS-only по умолчанию + явное включение embeddings + ограничение источников (Saved Messages/свои чаты) + предупреждения.
- “Deep link до Saved Messages” может быть не гарантирован → fallback на открытие чата + время/фрагмент.
- Извлечение текста из PDF/DOCX может быть “грязным” → best-effort + прозрачные статусы ошибок.

