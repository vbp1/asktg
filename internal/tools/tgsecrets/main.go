package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/base64"
	"encoding/binary"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

const (
	defaultIn  = "tg_secrets.local.json"
	defaultOut = "tg_secrets_generated.go"
)

type payload struct {
	ID   int    `json:"id"`
	Hash string `json:"hash"`
}

func main() {
	inPath := flag.String("in", defaultIn, "path to local secrets json (gitignored)")
	outPath := flag.String("out", defaultOut, "path to generated go file (gitignored)")
	flag.Parse()

	raw, err := os.ReadFile(filepath.Clean(*inPath))
	if err != nil {
		fatal(fmt.Errorf("read %s: %w", *inPath, err))
	}

	var p payload
	if err := json.Unmarshal(raw, &p); err != nil {
		fatal(fmt.Errorf("parse %s: %w", *inPath, err))
	}
	p.Hash = strings.TrimSpace(p.Hash)
	if p.ID <= 0 || p.Hash == "" {
		fatal(errors.New("invalid secrets file: expected {\"id\": <positive int>, \"hash\": \"...\"}"))
	}

	// "Random string" stored in the binary too â€” this is obfuscation, not true secrecy.
	seed := make([]byte, 32)
	if _, err := rand.Read(seed); err != nil {
		fatal(err)
	}

	nonce := make([]byte, 12)
	if _, err := rand.Read(nonce); err != nil {
		fatal(err)
	}

	plain, err := json.Marshal(payload{ID: p.ID, Hash: p.Hash})
	if err != nil {
		fatal(err)
	}

	block, err := aes.NewCipher(seed)
	if err != nil {
		fatal(err)
	}
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		fatal(err)
	}
	ciphertext := gcm.Seal(nil, nonce, plain, nil)

	// Store encrypted payload as a single base64 string.
	blob := base64.StdEncoding.EncodeToString(append(nonce, ciphertext...))

	// Store the random string as masked uint64 parts to avoid easy `strings.exe` extraction.
	type part struct {
		masked uint64
		mask   uint64
	}
	parts := make([]part, 4)
	for i := 0; i < 4; i++ {
		var chunk [8]byte
		copy(chunk[:], seed[i*8:(i+1)*8])
		chunkU := binary.LittleEndian.Uint64(chunk[:])
		var maskBytes [8]byte
		if _, err := rand.Read(maskBytes[:]); err != nil {
			fatal(err)
		}
		maskU := binary.LittleEndian.Uint64(maskBytes[:])
		parts[i] = part{masked: chunkU ^ maskU, mask: maskU}
	}

	dir, err := os.Getwd()
	if err != nil {
		fatal(err)
	}
	target := filepath.Join(dir, *outPath)

	contents := fmt.Sprintf(`// Code generated by "go generate"; DO NOT EDIT.
package main

import (
  "crypto/aes"
  "crypto/cipher"
  "encoding/base64"
  "encoding/binary"
  "encoding/json"
)

type tgPayload struct {
  ID   int    %s
  Hash string %s
}

const tgBlobB64 = %q

const (
  tgK0Masked uint64 = 0x%016x
  tgK0Mask   uint64 = 0x%016x
  tgK1Masked uint64 = 0x%016x
  tgK1Mask   uint64 = 0x%016x
  tgK2Masked uint64 = 0x%016x
  tgK2Mask   uint64 = 0x%016x
  tgK3Masked uint64 = 0x%016x
  tgK3Mask   uint64 = 0x%016x
)

func init() {
  embeddedTelegramCredentialsFunc = func() (int, string, bool) {
    raw, err := base64.StdEncoding.DecodeString(tgBlobB64)
    if err != nil || len(raw) < 12 {
      return 0, "", false
    }
    nonce := raw[:12]
    ciphertext := raw[12:]

    var key [32]byte
    binary.LittleEndian.PutUint64(key[0:8], tgK0Masked^tgK0Mask)
    binary.LittleEndian.PutUint64(key[8:16], tgK1Masked^tgK1Mask)
    binary.LittleEndian.PutUint64(key[16:24], tgK2Masked^tgK2Mask)
    binary.LittleEndian.PutUint64(key[24:32], tgK3Masked^tgK3Mask)

    block, err := aes.NewCipher(key[:])
    if err != nil {
      return 0, "", false
    }
    gcm, err := cipher.NewGCM(block)
    if err != nil {
      return 0, "", false
    }
    plain, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
      return 0, "", false
    }
    var p tgPayload
    if err := json.Unmarshal(plain, &p); err != nil {
      return 0, "", false
    }
    if p.ID <= 0 || p.Hash == "" {
      return 0, "", false
    }
    return p.ID, p.Hash, true
  }
}
`,
		"`json:\"id\"`",
		"`json:\"hash\"`",
		blob,
		parts[0].masked, parts[0].mask,
		parts[1].masked, parts[1].mask,
		parts[2].masked, parts[2].mask,
		parts[3].masked, parts[3].mask,
	)

	if err := os.WriteFile(target, []byte(contents), 0o644); err != nil {
		fatal(err)
	}
}

func fatal(err error) {
	_, _ = fmt.Fprintln(os.Stderr, "tgsecrets:", err)
	os.Exit(2)
}
